function RectifiedImages = rectifyImages(ILeft, IRight, KLeft, KRight, R, T)

% returns rectified left and right image
%
% Params:
% KLeft - Left callibrations matrix
% KRight - right callibration matrix
% R - Rotation matrix wrt left camera
% T - Translation vector wrt left camera


% Transformation matrizes
Po1 = KLeft * [1 0 0 0; 0 1 0 0; 0 0 1 0];
Po2 = KRight * [R T];

disp('---------------------------------- rectifying...')

%  rectification without centeriing
[TL,TR,pml1,pmr1] = rectify(Po1,Po2);

% centering LEFT image
p = [size(ILeft,1)/2; size(ILeft,2)/2; 1];
px = TL * p;
dL = p(1:2) - px(1:2)./px(3);

% centering RIGHT image
p2 = [size(IRight,1)/2; size(IRight,2)/2; 1];
px2 = TR * p2; 
dR = p2(1:2) - px2(1:2)./px2(3);

% vertical diplacement must be the same
dL(2) = dR(2);


% rectification with centering
[TL,TR,pml1,pmr12] = rectify(Po1,Po2,dL,dR);


disp('---------------------------------- warping...')

% find the smallest bounding box containining both images
bb = mcbb(size(ILeft),size(IRight), TL, TR);

% warp RGB channels,
for c = 1:3

    % Warp LEFT
    [JL(:,:,c),bbL,alphaL] = imwarp2(ImageL(:,:,c), TL, 'bilinear', bb);

    % Warp RIGHT
    [JR(:,:,c),bbR,alphaR] = imwarp2(ImageR(:,:,c), TR, 'bilinear', bb);

end

bb2 = mcbb(size(ImageL),size(ImageR), TL2, TR2);

% warp RGB channels,
for c = 1:3

    % Warp LEFT
    [JL2(:,:,c),bbL,alphaL] = imwarp2(ImageL(:,:,c), TL2, 'bilinear', bb2);

    % Warp RIGHT
    [JR2(:,:,c),bbR,alphaR] = imwarp2(ImageR(:,:,c), TR2, 'bilinear', bb2);

end